<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>three.js ar - dragging</title>
</head>
<body>

<div id="info">
	forked <a href=https://code4fukui.github.io/three.js_examples/?q=webxr#webxr_ar_dragging>ar - dragging</a> / <a href="https://threejs.org">three.js</a><br>
	<a href="./">colorfull</a><br>
	<a href="?grayscale=true">grayscale</a><br>
	<a href="?grayscale=true&opacity=1.0">gray scale and no transparency</a><br>
	<a href="?opacity=1.0">colorfull and no transparency</a><br>
</div>

<style>
body {
	margin: 0;
	font-family: sans-serif;
}
#info {
	position: absolute;
	background-color: rgba(155, 155, 155, 0.5);
	padding: 0.5em;
	margin: 0.5em;
	color: #111;
}
a {
	color: #228 !important;
}
</style>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
	"imports": {
		"three": "https://code4fukui.github.io/three.js/build/three.module.js",
		"three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
	}
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js"; // for PC
import { ARButton } from "three/addons/webxr/ARButton.js";

let container;
let camera, scene, renderer;
let controller1, controller2;

let raycaster;

const intersected = [];
const tempMatrix = new THREE.Matrix4();

let group;

const onWindowResize = () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
};

const isTouch = (intersection) => {
	const d = intersection.distance;
	return d > 0 && d < .10;
};

const onSelectStart = (event) => {
	const controller = event.target;
	const intersections = getIntersections(controller);
	const objects = [];
	for (const intersection of intersections) {
		const object = intersection.object;
		object.material.emissive.b = 1;
		controller.attach(object);
		objects.push(object);
		if (isTouch(intersection)) {
			break;
		}
	}
	controller.userData.selected = objects;
};

const onSelectEnd = (event) => {
	const controller = event.target;
	if (controller.userData.selected !== undefined) {
		for (const object of controller.userData.selected) {
			object.material.emissive.b = 0;
			group.attach(object);
		}
		controller.userData.selected = undefined;
	}
};

const getIntersections = (controller) => {
	tempMatrix.identity().extractRotation(controller.matrixWorld);
	raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
	raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
	return raycaster.intersectObjects(group.children, false);
};

const intersectObjects = (controller) => {
	// Do not highlight when already selected
	if (controller.userData.selected !== undefined) return;

	const intersections = getIntersections(controller);
	for (const intersection of intersections) {
		const object = intersection.object;
		object.material.emissive.r = 1;
		intersected.push(object);
		if (isTouch(intersection)) {
			object.material.emissive.g = 1;
			break;
		}
	}
};

const cleanIntersected = () => {
	while (intersected.length) {
		const object = intersected.pop();
		object.material.emissive.r = 0;
		object.material.emissive.g = 0;
	}
};

const render = () => {
	cleanIntersected();
	intersectObjects(controller1);
	intersectObjects(controller2);
	renderer.render(scene, camera);
};
const animate = () => {
	renderer.setAnimationLoop(render);
};

const init = () => {
	container = document.createElement("div");
	document.body.appendChild(container);

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
	camera.position.set(0, 0, 3);

	const controls = new OrbitControls(camera, container);
	controls.minDistance = 0;
	controls.maxDistance = 8;

	scene.add(new THREE.HemisphereLight(0x808080, 0x606060));

	const light = new THREE.DirectionalLight(0xffffff);
	light.position.set(0, 6, 0);
	scene.add(light);

	group = new THREE.Group();
	scene.add(group);

	const geometries = [
		new THREE.BoxGeometry(1.6, 0.8, 0.1),
		new THREE.BoxGeometry(0.2, 0.2, 0.2),
		new THREE.BoxGeometry(0.2, 0.4, 0.2),
		new THREE.BoxGeometry(0.4, 0.4, 0.1),
		new THREE.ConeGeometry(0.1, 0.2, 64),
		new THREE.CylinderGeometry(0.1, 0.1, 0.2, 64),
		new THREE.CylinderGeometry(0.1, 0.1, 0.8, 64),
		new THREE.IcosahedronGeometry(0.1, 8),
		new THREE.TorusGeometry(0.2 - 0.04, 0.04, 64, 32)
	];

	//const grayscale = true;
	const param = new URL(location.href).searchParams;
	const grayscale = param.get("grayscale") || false;
	const opacity = parseFloat(param.get("opacity")) || 0.8;
	console.log(param, opacity);
	for (let i = 0; i < 100; i++) {
		const geometry = geometries[Math.floor(Math.random() * geometries.length)];
		const getColor = () => {
			if (grayscale) {
				const nc = (Math.random() * 0x100) >> 0;
				const color = (nc << 16) | (nc << 8) | nc;
				return color;
			}
			return Math.random() * 0x1000000;
		};
		const material = new THREE.MeshStandardMaterial({
			color: getColor(),
			roughness: 1.0,
			metalness: 0.0,
			transparent: opacity < 1.0,
			opacity,
		});

		const object = new THREE.Mesh(geometry, material);

		object.position.x = Math.random() * 4 - 2;
		object.position.y = Math.random() * 4 - 2;
		object.position.z = Math.random() * 4 - 2;

		object.rotation.x = Math.random() * 2 * Math.PI;
		object.rotation.y = Math.random() * 2 * Math.PI;
		object.rotation.z = Math.random() * 2 * Math.PI;

		//object.scale.setScalar(Math.random() / 2 + 0.5);

		group.add(object);
	}

	//

	renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.outputEncoding = THREE.sRGBEncoding;
	renderer.xr.enabled = true;
	container.appendChild(renderer.domElement);

	document.body.appendChild(ARButton.createButton(renderer));

	// controllers

	controller1 = renderer.xr.getController(0);
	controller1.addEventListener("selectstart", onSelectStart);
	controller1.addEventListener("selectend", onSelectEnd);
	scene.add(controller1);

	controller2 = renderer.xr.getController(1);
	controller2.addEventListener("selectstart", onSelectStart);
	controller2.addEventListener("selectend", onSelectEnd);
	scene.add(controller2);

	raycaster = new THREE.Raycaster();

	//
	window.addEventListener("resize", onWindowResize);
};

init();
animate();

</script>
</body>
</html>
